# Redis ãƒ‡ãƒ¼ã‚¿æ§‹é€  å®Œå…¨æ´»ç”¨ã‚¬ã‚¤ãƒ‰

## æ¦‚è¦

Redisã®ä¸»è¦ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆString/JSONã€Hashã€Streamsã€Pub/Subï¼‰ã®ç‰¹å¾´ã€é©ç”¨ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã€Rustã§ã®å®Ÿè£…é›£æ˜“åº¦ã‚’ç¶²ç¾…çš„ã«ã¾ã¨ã‚ãŸãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã§ã™ã€‚

---

## 1. String / JSON

### ç‰¹å¾´
- **æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«**ãªKey-Valueã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
- ãƒã‚¤ãƒŠãƒªã‚»ãƒ¼ãƒ•ï¼ˆç”»åƒã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚ä¿å­˜å¯èƒ½ï¼‰
- **RedisJSON**ä½¿ç”¨æ™‚ã¯JSONæ“ä½œãŒå¯èƒ½
- **åŸå­çš„æ“ä½œ**ï¼ˆINCRã€APPENDç­‰ï¼‰å¯¾å¿œ

### é©ç”¨ãƒ‡ãƒ¼ã‚¿
- ã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ…å ±
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿
- è¨­å®šå€¤ãƒ»ãƒ•ãƒ©ã‚°
- ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
- ä¸€æ™‚çš„ãªãƒˆãƒ¼ã‚¯ãƒ³

### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

#### âœ… å‘ã„ã¦ã„ã‚‹
- **Webã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†**
- **APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥**
- **èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ä¿å­˜**
- **ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼ˆPVã€ã„ã„ã­æ•°ï¼‰**
- **æ©Ÿèƒ½ãƒ•ãƒ©ã‚°ãƒ»è¨­å®šç®¡ç†**

#### âŒ å‘ã„ã¦ã„ãªã„
- éƒ¨åˆ†æ›´æ–°ãŒé »ç¹ãªãƒ‡ãƒ¼ã‚¿
- è¤‡é›‘ãªæ¤œç´¢ãŒå¿…è¦ãªãƒ‡ãƒ¼ã‚¿
- ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒŠãƒ«ãªãƒ‡ãƒ¼ã‚¿

### Rustã§ã®ä½¿ã„ã‚„ã™ã•ï¼šâ­â­â­â­â­

```rust
// éå¸¸ã«ã‚·ãƒ³ãƒ—ãƒ«
async fn cache_user_session(redis: &Connection, user_id: Uuid, session: &Session) -> Result<()> {
    let key = format!("session:{}", user_id);
    let json = serde_json::to_string(session)?;
    redis.set_ex(&key, &json, 3600).await?; // 1æ™‚é–“TTL
    Ok(())
}

async fn get_cached_session(redis: &Connection, user_id: Uuid) -> Result<Option<Session>> {
    let key = format!("session:{}", user_id);
    let json: Option<String> = redis.get(&key).await?;
    match json {
        Some(data) => Ok(Some(serde_json::from_str(&data)?)),
        None => Ok(None),
    }
}

// RedisJSONä½¿ç”¨ï¼ˆã‚ˆã‚Šé«˜é€Ÿï¼‰
async fn update_user_profile_json(redis: &Connection, user_id: Uuid, name: &str) -> Result<()> {
    let key = format!("user:{}", user_id);
    redis::cmd("JSON.SET")
        .arg(&key)
        .arg("$.name")
        .arg(name)
        .query_async(redis).await?;
    Ok(())
}
```

**ãƒ¡ãƒªãƒƒãƒˆ**
- Serdeã§è‡ªå‹•ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
- ã‚¨ãƒ©ãƒ¼å‡¦ç†ãŒã‚·ãƒ³ãƒ—ãƒ«
- TTLè¨­å®šãŒç°¡å˜

**ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**
- å¤§ããªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®éƒ¨åˆ†æ›´æ–°ã¯éåŠ¹ç‡

---

## 2. Hash

### ç‰¹å¾´
- **ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰-å€¤**ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆæ§‹é€ ä½“ãƒ©ã‚¤ã‚¯ï¼‰
- **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**ãŒæœ€é«˜
- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å˜ä½ã§ã®æ“ä½œãŒå¯èƒ½
- **åŸå­çš„**ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ“ä½œ

### é©ç”¨ãƒ‡ãƒ¼ã‚¿
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«
- å•†å“æƒ…å ±
- è¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
- ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ»çµ±è¨ˆãƒ‡ãƒ¼ã‚¿
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£

### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

#### âœ… å‘ã„ã¦ã„ã‚‹
- **ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç®¡ç†**
- **å•†å“ã‚«ã‚¿ãƒ­ã‚°ã‚­ãƒ£ãƒƒã‚·ãƒ¥**
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹**
- **é »ç¹ã«éƒ¨åˆ†æ›´æ–°ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿**
- **æ§‹é€ åŒ–ã•ã‚ŒãŸã‚­ãƒ£ãƒƒã‚·ãƒ¥**

#### âŒ å‘ã„ã¦ã„ãªã„
- ãƒã‚¹ãƒˆã—ãŸè¤‡é›‘ãªæ§‹é€ 
- å¤§é‡ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ1000+ï¼‰
- æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿

### Rustã§ã®ä½¿ã„ã‚„ã™ã•ï¼šâ­â­â­

```rust
// æ‰‹å‹•ãƒãƒƒãƒ”ãƒ³ã‚°ãŒå¿…è¦ã ãŒé«˜æ€§èƒ½
async fn save_user_profile(redis: &Connection, user: &User) -> Result<()> {
    let key = format!("user:{}", user.id);
    
    redis::pipe()
        .hset(&key, "id", user.id.to_string())
        .hset(&key, "email", user.email.as_deref().unwrap_or(""))
        .hset(&key, "name", user.name.as_deref().unwrap_or(""))
        .hset(&key, "last_login", user.last_login.map(|t| t.timestamp()).unwrap_or(0))
        .hset(&key, "status", user.status.to_string())
        .expire(&key, 3600)
        .query_async(redis).await?;
    Ok(())
}

async fn get_user_profile(redis: &Connection, user_id: Uuid) -> Result<Option<User>> {
    let key = format!("user:{}", user_id);
    let hash: HashMap<String, String> = redis.hgetall(&key).await?;
    
    if hash.is_empty() {
        return Ok(None);
    }
    
    // æ‰‹å‹•ã§ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºï¼ˆé¢å€’ã ãŒé«˜é€Ÿï¼‰
    let user = User {
        id: Uuid::parse_str(&hash["id"])?,
        email: hash.get("email").filter(|s| !s.is_empty()).cloned(),
        name: hash.get("name").filter(|s| !s.is_empty()).cloned(),
        last_login: hash.get("last_login")
            .and_then(|s| s.parse::<i64>().ok())
            .map(|ts| DateTime::from_timestamp(ts, 0).unwrap()),
        status: hash.get("status")
            .and_then(|s| UserStatus::from_str(s).ok())
            .unwrap_or_default(),
    };
    Ok(Some(user))
}

// ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å˜ä½ã®é«˜é€Ÿæ›´æ–°
async fn update_last_login(redis: &Connection, user_id: Uuid) -> Result<()> {
    let key = format!("user:{}", user_id);
    let timestamp = Utc::now().timestamp();
    redis.hset(&key, "last_login", timestamp).await?;
    Ok(())
}
```

**ãƒ¡ãƒªãƒƒãƒˆ**
- æœ€é«˜ã®ãƒ¡ãƒ¢ãƒªåŠ¹ç‡
- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å˜ä½æ“ä½œãŒé«˜é€Ÿ
- éƒ¨åˆ†æ›´æ–°ãŒç°¡å˜

**ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**
- æ‰‹å‹•å‹å¤‰æ›ãŒå¿…è¦
- Optionå‹ã®æ‰±ã„ãŒé¢å€’
- ãƒã‚¹ãƒˆã—ãŸæ§‹é€ ã¯ä¸å¯

---

## 3. Streams

### ç‰¹å¾´
- **æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿**å°‚ç”¨
- **è‡ªå‹•IDç”Ÿæˆ**ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒ™ãƒ¼ã‚¹ï¼‰
- **ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—**ã§åˆ†æ•£å‡¦ç†
- **æ°¸ç¶šåŒ–**ã•ã‚ŒãŸé †åºä¿è¨¼
- **Rangeæ¤œç´¢**å¯¾å¿œ

### é©ç”¨ãƒ‡ãƒ¼ã‚¿
- ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£
- ç›£æŸ»ãƒ­ã‚°
- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼
- ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿

### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

#### âœ… å‘ã„ã¦ã„ã‚‹
- **ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°**
- **ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•åˆ†æ**
- **ç›£æŸ»ãƒ­ã‚°ãƒ»ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹**
- **éåŒæœŸã‚¿ã‚¹ã‚¯ã‚­ãƒ¥ãƒ¼**
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ†æ**
- **ãƒãƒ£ãƒƒãƒˆãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ **

#### âŒ å‘ã„ã¦ã„ãªã„
- å˜ç´”ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥
- é™çš„ãªãƒã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿
- é »ç¹ãªå‰Šé™¤ãƒ»æ›´æ–°ãŒå¿…è¦ãªãƒ‡ãƒ¼ã‚¿

### Rustã§ã®ä½¿ã„ã‚„ã™ã•ï¼šâ­â­

```rust
// ã‚¤ãƒ™ãƒ³ãƒˆã®è¿½åŠ ã¯ç°¡å˜
async fn log_user_activity(redis: &Connection, activity: &UserActivity) -> Result<String> {
    let stream_key = "user_activities";
    
    let entry_id: String = redis::cmd("XADD")
        .arg(stream_key)
        .arg("*") // è‡ªå‹•IDç”Ÿæˆ
        .arg("user_id").arg(activity.user_id.to_string())
        .arg("action").arg(&activity.action)
        .arg("timestamp").arg(activity.timestamp.to_rfc3339())
        .arg("metadata").arg(serde_json::to_string(&activity.metadata)?)
        .query_async(redis).await?;
    
    Ok(entry_id)
}

// Rangeæ¤œç´¢ï¼ˆæ™‚ç³»åˆ—åˆ†æï¼‰
async fn get_user_activities_in_range(
    redis: &Connection, 
    start_time: DateTime<Utc>, 
    end_time: DateTime<Utc>
) -> Result<Vec<UserActivity>> {
    let start_id = format!("{}-0", start_time.timestamp_millis());
    let end_id = format!("{}-0", end_time.timestamp_millis());
    
    let entries: Vec<redis::Value> = redis::cmd("XRANGE")
        .arg("user_activities")
        .arg(start_id)
        .arg(end_id)
        .query_async(redis).await?;
    
    // ãƒ‘ãƒ¼ã‚¹å‡¦ç†ï¼ˆè¤‡é›‘ï¼‰
    let activities = parse_stream_entries(entries)?;
    Ok(activities)
}

// ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ã§ã®åˆ†æ•£å‡¦ç†
async fn process_activities_worker(redis: &Connection, worker_id: &str) -> Result<()> {
    loop {
        let messages: Vec<redis::Value> = redis::cmd("XREADGROUP")
            .arg("GROUP").arg("activity_processors").arg(worker_id)
            .arg("COUNT").arg(10)
            .arg("STREAMS").arg("user_activities").arg(">")
            .query_async(redis).await?;
        
        for message in messages {
            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
            process_activity_message(message).await?;
            
            // å‡¦ç†å®Œäº†ã‚’ACK
            redis::cmd("XACK")
                .arg("user_activities")
                .arg("activity_processors")
                .arg(message_id)
                .query_async(redis).await?;
        }
    }
}
```

**ãƒ¡ãƒªãƒƒãƒˆ**
- æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã®å®Œç’§ãªç®¡ç†
- åˆ†æ•£å‡¦ç†ã®ãƒã‚¤ãƒ†ã‚£ãƒ–ã‚µãƒãƒ¼ãƒˆ
- éšœå®³æ™‚ã®å¾©æ—§æ©Ÿèƒ½

**ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**
- ãƒ‘ãƒ¼ã‚¹å‡¦ç†ãŒè¤‡é›‘
- å­¦ç¿’ã‚³ã‚¹ãƒˆãŒé«˜ã„
- ãƒ‡ãƒãƒƒã‚°ãŒå›°é›£

---

## 4. Pub/Sub

### ç‰¹å¾´
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°
- **å¤šå¯¾å¤š**é€šä¿¡
- **æ°¸ç¶šåŒ–ã•ã‚Œãªã„**ï¼ˆæ®ç™ºæ€§ï¼‰
- **ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°**ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–
- **éåŒæœŸ**é€šä¿¡

### é©ç”¨ãƒ‡ãƒ¼ã‚¿
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥
- ãƒ©ã‚¤ãƒ–ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
- ã‚¤ãƒ™ãƒ³ãƒˆé…ä¿¡
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹åŒ–ä¿¡å·
- ã‚·ã‚¹ãƒ†ãƒ é–“é€£æº

### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

#### âœ… å‘ã„ã¦ã„ã‚‹
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ **
- **ãƒ©ã‚¤ãƒ–ãƒãƒ£ãƒƒãƒˆ**
- **WebSocketãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ**
- **ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹åŒ–**
- **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡**
- **ãƒ©ã‚¤ãƒ–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰**

#### âŒ å‘ã„ã¦ã„ãªã„
- ç¢ºå®Ÿãªé…ä¿¡ãŒå¿…è¦ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- æ°¸ç¶šåŒ–ãŒå¿…è¦ãªãƒ‡ãƒ¼ã‚¿
- é †åºä¿è¨¼ãŒé‡è¦ãªãƒ‡ãƒ¼ã‚¿

### Rustã§ã®ä½¿ã„ã‚„ã™ã•ï¼šâ­â­â­â­

```rust
// ãƒ‘ãƒ–ãƒªãƒƒã‚·ãƒ£ãƒ¼ï¼ˆé€ä¿¡å´ï¼‰
async fn notify_user_update(redis: &Connection, user_id: Uuid, event: &str) -> Result<()> {
    let channel = format!("user_updates:{}", user_id);
    let message = serde_json::to_string(&UserUpdateEvent {
        user_id,
        event: event.to_string(),
        timestamp: Utc::now(),
    })?;
    
    redis.publish(&channel, &message).await?;
    Ok(())
}

// å…¨ä½“ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ
async fn broadcast_system_maintenance(redis: &Connection) -> Result<()> {
    let message = SystemMessage {
        level: "warning".to_string(),
        content: "System maintenance in 10 minutes".to_string(),
        timestamp: Utc::now(),
    };
    
    redis.publish("system_broadcasts", serde_json::to_string(&message)?).await?;
    Ok(())
}

// ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒãƒ¼ï¼ˆå—ä¿¡å´ï¼‰
async fn listen_to_user_updates(redis: &Connection, user_id: Uuid) -> Result<()> {
    let mut pubsub = redis.get_async_connection().await?.into_pubsub();
    let channel = format!("user_updates:{}", user_id);
    pubsub.subscribe(&channel).await?;
    
    let mut stream = pubsub.into_on_message();
    
    while let Some(msg) = stream.next().await {
        let payload: String = msg.get_payload()?;
        let event: UserUpdateEvent = serde_json::from_str(&payload)?;
        
        // ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
        handle_user_update_event(event).await?;
    }
    
    Ok(())
}

// ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–
async fn listen_to_all_notifications(redis: &Connection) -> Result<()> {
    let mut pubsub = redis.get_async_connection().await?.into_pubsub();
    pubsub.psubscribe("notifications:*").await?; // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ
    
    let mut stream = pubsub.into_on_message();
    
    while let Some(msg) = stream.next().await {
        let channel: String = msg.get_channel_name();
        let payload: String = msg.get_payload()?;
        
        println!("Received from {}: {}", channel, payload);
    }
    
    Ok(())
}
```

**ãƒ¡ãƒªãƒƒãƒˆ**
- å®Ÿè£…ãŒæ¯”è¼ƒçš„ç°¡å˜
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§ãŒæœ€é«˜
- ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ãŒä¾¿åˆ©

**ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ**
- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ®ç™ºæ€§
- ç¢ºå®Ÿãªé…ä¿¡ä¿è¨¼ãªã—
- å—ä¿¡è€…ãŒã„ãªã„ã¨æ¶ˆå¤±

---

## æœ€é©ãªçµ„ã¿åˆã‚ã›æˆ¦ç•¥

### ğŸ¯ æ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³

#### **1. Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³**
```rust
// String/JSON: ã‚»ãƒƒã‚·ãƒ§ãƒ³ã€è¨­å®š
// Hash: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã€å•†å“æƒ…å ±
// Pub/Sub: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥
// Streams: ç›£æŸ»ãƒ­ã‚°
```

#### **2. E-commerce**
```rust
// String: å•†å“åœ¨åº«ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
// Hash: å•†å“è©³ç´°ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚«ãƒ¼ãƒˆ
// Streams: æ³¨æ–‡å±¥æ­´ã€åœ¨åº«å¤‰å‹•ãƒ­ã‚°
// Pub/Sub: åœ¨åº«åˆ‡ã‚Œé€šçŸ¥ã€ä¾¡æ ¼æ›´æ–°
```

#### **3. IoTãƒ»åˆ†æã‚·ã‚¹ãƒ†ãƒ **
```rust
// Hash: ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã€è¨­å®š
// Streams: ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°
// Pub/Sub: ã‚¢ãƒ©ãƒ¼ãƒˆã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
// String: é›†è¨ˆçµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥
```

#### **4. ãƒãƒ£ãƒƒãƒˆãƒ»SNS**
```rust
// Hash: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«
// Streams: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£
// Pub/Sub: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…ä¿¡
// String: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ã€æœªèª­æ•°
```

---

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ

| æ“ä½œ | String/JSON | Hash | Streams | Pub/Sub |
|------|-------------|------|---------|---------|
| **èª­ã¿å–ã‚Š** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| **æ›¸ãè¾¼ã¿** | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **éƒ¨åˆ†æ›´æ–°** | â­â­ | â­â­â­â­â­ | âŒ | âŒ |
| **Rangeæ¤œç´¢** | âŒ | âŒ | â­â­â­â­â­ | âŒ |
| **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡** | â­â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |

---

## ã¾ã¨ã‚

### ğŸš€ **é–‹ç™ºé€Ÿåº¦é‡è¦–**: String/JSON + Pub/Sub
- ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã€MVPé–‹ç™º
- Serdeã§æ¥½ã€…ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

### âš¡ **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–**: Hash + Streams
- æœ¬æ ¼é‹ç”¨ã€å¤§è¦æ¨¡ã‚·ã‚¹ãƒ†ãƒ 
- ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã¨é€Ÿåº¦ã®æœ€é©åŒ–

### ğŸ”„ **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é‡è¦–**: Pub/Sub + Hash
- ãƒ©ã‚¤ãƒ–ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“

### ğŸ“Š **åˆ†æãƒ»ãƒ­ã‚°é‡è¦–**: Streams + Hash
- ãƒ‡ãƒ¼ã‚¿ãƒ‰ãƒªãƒ–ãƒ³ãªæ„æ€æ±ºå®š
- ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹å¯¾å¿œ

**æœ€çµ‚çš„ã«ã¯ç”¨é€”ã«å¿œã˜ã¦é©åˆ‡ã«çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€Redisã®çœŸã®åŠ›ã‚’ç™ºæ®ã§ãã¾ã™ã€‚**