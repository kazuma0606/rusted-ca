# ğŸ¦€ True Rusted Clean Architecture (çœŸã®Rusted CA)

## ğŸ¯ è¨­è¨ˆå“²å­¦

**ã€ŒRustã®ç‰¹æ€§ã‚’æ´»ã‹ã—ã€CAã®ç¾ã—ã•ã‚’æœ€å¤§åŒ–ã™ã‚‹ã€**

- âœ… **Lightning Clean Commerce ã®æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³**ã‚’åŸºç›¤ã¨ã™ã‚‹
- âœ… **In-Memory CQRS**ã§CAã®ç¾ã—ã•ã«é›†ä¸­
- âœ… **å±¤åˆ¥Resultå‹**ã§ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæºã‚’æ˜ç¢ºåŒ–
- âœ… **ã‚¸ã‚§ãƒãƒªãƒƒã‚¯åˆ¶ç´„**ã«ã‚ˆã‚‹å‹å®‰å…¨æ€§ã®å¾¹åº•
- âœ… **Value Objects**ã«ã‚ˆã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ«å®Ÿè£…

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å…¨ä½“å›³

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Presentation Layer                           â”‚
â”‚  HTTP Request â†’ Controller â†’ PresentationResult<Response>       â”‚
â”‚  PresentationError (400, 401, 403, 404, 500)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Application Layer                             â”‚
â”‚  Command/Query â†’ UseCase â†’ ApplicationResult<DTO>              â”‚
â”‚  ApplicationError (UserNotFound, EmailExists, Validation...)   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Domain Layer                                â”‚
â”‚  Value Objects â†’ Entity â†’ DomainResult<Entity>                 â”‚
â”‚  DomainError (InvalidEmail, BusinessRuleViolation...)          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                Infrastructure Layer                             â”‚
â”‚  In-Memory CQRS â†’ Repository â†’ InfrastructureResult<Data>      â”‚
â”‚  InfrastructureError (Database, Network, ExternalService...)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ CQRS Data Flow

### Command Side (Write)
```
HTTP Request â†’ CreateUserRequest â†’ CreateUserCommand 
    â†“
UseCase<T: CommandRepository, U: IdGenerator> 
    â†“
User Entity (Value Objects) â†’ CommandRepository 
    â†“
In-Memory Normalized Store â†’ UserResponse
```

### Query Side (Read)
```
HTTP Request â†’ GetUserQuery 
    â†“
UseCase<T: QueryRepository> 
    â†“
QueryRepository â†’ In-Memory Denormalized Store 
    â†“
UserResponseDto â†’ HTTP Response
```

## ğŸ“‹ å®Œå…¨ãªå‹å®šç¾©

### å±¤åˆ¥Resultå‹
```rust
// Domain Layer
pub type DomainResult<T> = Result<T, DomainError>;

// Application Layer  
pub type ApplicationResult<T> = Result<T, ApplicationError>;

// Infrastructure Layer
pub type InfrastructureResult<T> = Result<T, InfrastructureError>;

// Presentation Layer
pub type PresentationResult<T> = Result<T, PresentationError>;
```

### ã‚¨ãƒ©ãƒ¼è‡ªå‹•å¤‰æ›ãƒã‚§ãƒ¼ãƒ³
```rust
DomainError â†’ ApplicationError â†’ PresentationError
InfrastructureError â†’ ApplicationError â†’ PresentationError
```

### ã‚¸ã‚§ãƒãƒªãƒƒã‚¯åˆ¶ç´„ãƒ‘ã‚¿ãƒ¼ãƒ³
```rust
impl<T, U, V> CreateUserUsecaseInterface for CreateUserUseCase<T, U, V>
where
    T: UserCommandRepositoryInterface + Send + Sync,
    U: IdGeneratorInterface + Send + Sync,
    V: EmailServiceInterface + Send + Sync,
```

## ğŸ›ï¸ Layer Definitions

### Domain Layer
**è²¬å‹™**: ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã¨ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
```rust
// Value Objects (ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ«)
Email(String)     // ãƒ¡ãƒ¼ãƒ«ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
UserName(String)  // åå‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
Password { hash } // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–

// Entity (ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«é›†ç´„)
User {
    id: Uuid,
    email: Email,
    name: UserName,
    password: Password,
    // + ãƒ“ã‚¸ãƒã‚¹ãƒ¡ã‚½ãƒƒãƒ‰
}

// Repository Trait (ä¾å­˜æ€§é€†è»¢)
trait UserCommandRepositoryInterface
trait UserQueryRepositoryInterface
```

### Application Layer
**è²¬å‹™**: ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã¨ãƒ“ã‚¸ãƒã‚¹ãƒ•ãƒ­ãƒ¼
```rust
// Command/Query Objects
CreateUserCommand { email, name, password }
GetUserQuery { id }

// UseCase (ãƒ“ã‚¸ãƒã‚¹ãƒ•ãƒ­ãƒ¼)
CreateUserUseCase<T, U, V> {
    command_repository: Arc<T>,
    id_generator: Arc<U>,
    email_service: Arc<V>,
}

// DTO (å±¤é–“ãƒ‡ãƒ¼ã‚¿è»¢é€)
CreateUserRequestDto â†’ CreateUserResponseDto
```

### Infrastructure Layer
**è²¬å‹™**: å¤–éƒ¨ã‚·ã‚¹ãƒ†ãƒ ã¨ã®æ¥ç¶š
```rust
// In-Memory CQRS Implementation
InMemoryUserCommandRepository {
    // Writeæœ€é©åŒ–: æ­£è¦åŒ–ãƒ‡ãƒ¼ã‚¿
    store: HashMap<Uuid, User>,
    email_index: HashMap<String, Uuid>,
}

InMemoryUserQueryRepository {
    // Readæœ€é©åŒ–: éæ­£è¦åŒ–ãƒ‡ãƒ¼ã‚¿  
    read_models: HashMap<Uuid, UserReadModel>,
    search_index: HashMap<String, Vec<Uuid>>,
}
```

### Presentation Layer  
**è²¬å‹™**: HTTPå‡¦ç†ã¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå¤‰æ›
```rust
// HTTP DTO
CreateUserRequest { email, name, password }
UserResponse { id, email, name, created_at }

// Controller
async fn create_user<T: CreateUserUsecaseInterface>(
    State(usecase): State<Arc<T>>,
    Json(request): Json<CreateUserRequest>,
) -> PresentationResult<Json<ApiResponse<UserResponse>>>
```

## ğŸ”§ DI Pattern (Lightningæ–¹å¼)

### ç›´æ¥æ³¨å…¥ãƒ‘ã‚¿ãƒ¼ãƒ³
```rust
async fn setup_dependencies() -> AppState {
    // Infrastructure Layer
    let command_repository = Arc::new(InMemoryUserCommandRepository::new());
    let query_repository = Arc::new(InMemoryUserQueryRepository::new());
    let id_generator = Arc::new(UuidGenerator::new());
    
    // Application Layer - ã‚¸ã‚§ãƒãƒªãƒƒã‚¯åˆ¶ç´„
    let create_user_usecase = Arc::new(CreateUserUseCase::new(
        command_repository.clone(),
        id_generator.clone(),
    ));
    
    let get_user_usecase = Arc::new(GetUserUseCase::new(
        query_repository.clone(),
    ));
    
    AppState {
        create_user_usecase,
        get_user_usecase,
    }
}
```

## ğŸ“ SOLID Principles Implementation

### Single Responsibility Principle
- **Controller**: HTTPå‡¦ç†ã®ã¿
- **UseCase**: ãƒ“ã‚¸ãƒã‚¹ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã®ã¿  
- **Repository**: ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ã®ã¿
- **Entity**: ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ«ã®ã¿

### Open/Closed Principle
- æ–°ã—ã„Repositoryå®Ÿè£…è¿½åŠ å¯èƒ½
- æ–°ã—ã„UseCaseè¿½åŠ å¯èƒ½
- æ—¢å­˜ã‚³ãƒ¼ãƒ‰å¤‰æ›´ãªã—ã§æ‹¡å¼µ

### Liskov Substitution Principle
- Repository traitå®Ÿè£…ã®å·®ã—æ›¿ãˆå¯èƒ½
- Testã§Mockã«å·®ã—æ›¿ãˆå¯èƒ½

### Interface Segregation Principle
- CommandRepository / QueryRepository åˆ†é›¢
- UseCaseåˆ¥ã®Interfaceåˆ†é›¢

### Dependency Inversion Principle
- Application â†’ Domain â† Infrastructure
- æŠ½è±¡ã«ä¾å­˜ã€å…·è±¡ã«ä¾å­˜ã—ãªã„

## ğŸ¨ Value Objects Pattern

### ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ«å®Ÿè£…
```rust
impl Email {
    pub fn new(value: String) -> DomainResult<Self> {
        // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
        // æ­£è¦è¡¨ç¾ãƒã‚§ãƒƒã‚¯
        // ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«é©ç”¨
    }
}

impl Password {
    pub fn from_plain(plain: String) -> DomainResult<Self> {
        // å¼·åº¦ãƒã‚§ãƒƒã‚¯
        // bcryptãƒãƒƒã‚·ãƒ¥åŒ–
        // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ«ãƒ¼ãƒ«é©ç”¨
    }
}
```

## ğŸ”„ Type Conversion Matrix

| From â†’ To | Layer Boundary | Purpose |
|-----------|----------------|---------|
| `CreateUserRequest` â†’ `CreateUserCommand` | Presentation â†’ Application | HTTPå¢ƒç•Œåˆ†é›¢ |
| `CreateUserCommand` â†’ `User` | Application â†’ Domain | ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«é©ç”¨ |
| `User` â†’ `UserReadModel` | Domain â†’ Infrastructure | æ°¸ç¶šåŒ–å½¢å¼å¤‰æ› |
| `UserReadModel` â†’ `UserResponse` | Infrastructure â†’ Presentation | HTTPå‡ºåŠ›å¤‰æ› |

## ğŸ§ª Testing Strategy

### Unit Tests
```rust
// Domain Layer Test
#[test]
fn email_new_should_validate_format() {
    assert_eq!(
        Email::new("invalid".to_string()),
        Err(DomainError::InvalidEmail { ... })
    );
}

// Application Layer Test (Mock)
#[tokio::test] 
async fn create_user_should_fail_when_email_exists() {
    let mock_repo = MockUserRepository::new();
    mock_repo.expect_find_by_email().returning(|_| Ok(true));
    
    let usecase = CreateUserUseCase::new(Arc::new(mock_repo));
    let result = usecase.execute(command).await;
    
    assert_eq!(result, Err(ApplicationError::EmailAlreadyExists { ... }));
}
```

### Integration Tests
```rust
// Full API Test
#[tokio::test]
async fn create_user_api_should_return_201() {
    let app = create_test_app().await;
    
    let response = app
        .post("/api/users")
        .json(&create_user_request())
        .await;
        
    assert_eq!(response.status(), 201);
    // Response validation
}
```

## ğŸš€ Implementation Phases

### Phase 1: Domain Foundation (45min)
1. **Error Types**: å±¤åˆ¥Resultå‹å®šç¾©
2. **Value Objects**: Email, UserName, Password
3. **Entity**: User + ãƒ“ã‚¸ãƒã‚¹ãƒ¡ã‚½ãƒƒãƒ‰
4. **Repository Traits**: Command/Queryåˆ†é›¢

### Phase 2: Application Services (60min)
5. **Command/Query Objects**: CQRSå‹å®šç¾©
6. **UseCase Implementation**: ã‚¸ã‚§ãƒãƒªãƒƒã‚¯åˆ¶ç´„
7. **DTO Definitions**: å‹å¤‰æ›å®Ÿè£…
8. **Error Conversion**: è‡ªå‹•å¤‰æ›ãƒ†ã‚¹ãƒˆ

### Phase 3: Infrastructure (45min)
9. **In-Memory Command Repository**: Writeæœ€é©åŒ–
10. **In-Memory Query Repository**: Readæœ€é©åŒ–  
11. **Test Data Seeding**: åˆæœŸãƒ‡ãƒ¼ã‚¿æŠ•å…¥
12. **CQRS Synchronization**: Read/WriteåŒæœŸ

### Phase 4: Presentation (45min)
13. **HTTP DTOs**: Request/Response
14. **Controllers**: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
15. **Router Setup**: ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©
16. **Status Code Mapping**: HTTPå¿œç­”

### Phase 5: Integration (30min)
17. **DI Setup**: Lightningæ–¹å¼
18. **End-to-End Test**: å…¨ãƒ•ãƒ­ãƒ¼ç¢ºèª
19. **API Documentation**: ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä»•æ§˜
20. **Performance Validation**: å‹•ä½œé€Ÿåº¦ç¢ºèª

**Total: 3.5 hours**

## âœ¨ Unique Features of Rusted CA

### ğŸ¦€ **Rustã®ç‰¹æ€§æ´»ç”¨**
- **æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ **: ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§
- **å‹ã‚·ã‚¹ãƒ†ãƒ **: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã‚¨ãƒ©ãƒ¼æ¤œå‡º
- **ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹**: å‹å®‰å…¨ãªDI
- **ãƒˆãƒ¬ã‚¤ãƒˆ**: é©åˆ‡ãªæŠ½è±¡åŒ–

### ğŸ¨ **CAã®ç¾ã—ã•**
- **In-Memory CQRS**: ç´”ç²‹ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
- **å±¤åˆ¥Resultå‹**: ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæºæ˜ç¢ºåŒ–
- **Value Objects**: ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ«å®Ÿè£…
- **ä¾å­˜æ€§é€†è»¢**: å®Œå…¨ãªå±¤åˆ†é›¢

### âš¡ **é–‹ç™ºåŠ¹ç‡**
- **LightningæˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³**: å®Ÿè¨¼æ¸ˆã¿DI
- **æ®µéšçš„å®Ÿè£…**: ç¢ºå®Ÿãªé€²è¡Œ
- **å³åº§ã®å‹•ä½œç¢ºèª**: In-Memoryåˆ©ç‚¹
- **Future PostgreSQL**: å®¹æ˜“ãªç§»è¡Œ

---

**ã“ã‚ŒãŒçœŸã®Rusted Clean Architectureï¼**  
**Rustã®ç¾ã—ã•ã¨CAã®ç†æƒ³ãŒèåˆã—ãŸã€å®Œç’§ãªè¨­è¨ˆã§ã™ï¼** ğŸ¯ğŸ¦€âœ¨