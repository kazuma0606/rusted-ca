# ğŸ¨ Clean Architecture with In-Memory CQRS

## ğŸ¯ Strategy: Focus on CA Beauty First

### Why In-Memory Implementation?
âœ… **Focus on Architecture**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼ã«æ™‚é–“ã‚’å–ã‚‰ã‚Œãªã„  
âœ… **CQRSåˆ†é›¢ãŒç°¡å˜**: Read/Write ã‚¹ãƒˆã‚¢ã‚’æ˜ç¢ºã«åˆ†é›¢å¯èƒ½  
âœ… **é«˜é€Ÿé–‹ç™º**: æ¥ç¶šè¨­å®šä¸è¦ã§å³åº§ã«å‹•ä½œç¢ºèª  
âœ… **Pure CA**: ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç¾ã—ã•ãŒéš›ç«‹ã¤  

## ğŸ—„ï¸ In-Memory CQRS Design

### Command Store (Write Side)
```rust
// src/infrastructure/repository/in_memory_user_command_repository.rs

use crate::domain::entity::user::User;
use crate::domain::repository::user_repository::UserCommandRepositoryInterface;
use crate::shared::error::{InfrastructureError, InfrastructureResult};
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

pub struct InMemoryUserCommandRepository {
    // Writeå°‚ç”¨ã‚¹ãƒˆã‚¢ - æ­£è¦åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
    store: Arc<RwLock<HashMap<Uuid, User>>>,
    email_index: Arc<RwLock<HashMap<String, Uuid>>>, // ãƒ¡ãƒ¼ãƒ« â†’ ID ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
}

impl InMemoryUserCommandRepository {
    pub fn new() -> Self {
        Self {
            store: Arc::new(RwLock::new(HashMap::new())),
            email_index: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    // ãƒ†ã‚¹ãƒˆç”¨: åˆæœŸãƒ‡ãƒ¼ã‚¿æŠ•å…¥
    pub async fn seed_data(&self, users: Vec<User>) -> InfrastructureResult<()> {
        let mut store = self.store.write().await;
        let mut email_index = self.email_index.write().await;
        
        for user in users {
            email_index.insert(user.email().value().to_string(), user.id().clone());
            store.insert(user.id().clone(), user);
        }
        
        Ok(())
    }
}

#[async_trait]
impl UserCommandRepositoryInterface for InMemoryUserCommandRepository {
    async fn save(&self, user: &User) -> InfrastructureResult<()> {
        let mut store = self.store.write().await;
        let mut email_index = self.email_index.write().await;
        
        // ãƒ¡ãƒ¼ãƒ«é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆæ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ›´æ–°æ™‚ã¯é™¤å¤–ï¼‰
        if let Some(existing_id) = email_index.get(user.email().value()) {
            if existing_id != user.id() {
                return Err(InfrastructureError::Database {
                    message: format!("Email already exists: {}", user.email().value()),
                });
            }
        }
        
        email_index.insert(user.email().value().to_string(), user.id().clone());
        store.insert(user.id().clone(), user.clone());
        
        // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: Writeå´ã‹ã‚‰ Readå´ã¸ã®ãƒ‡ãƒ¼ã‚¿åŒæœŸ
        println!("[CQRS] Command executed: User {} saved", user.id());
        
        Ok(())
    }
    
    async fn delete(&self, id: &Uuid) -> InfrastructureResult<()> {
        let mut store = self.store.write().await;
        let mut email_index = self.email_index.write().await;
        
        if let Some(user) = store.remove(id) {
            email_index.remove(user.email().value());
            println!("[CQRS] Command executed: User {} deleted", id);
            Ok(())
        } else {
            Err(InfrastructureError::Database {
                message: format!("User not found: {}", id),
            })
        }
    }
    
    async fn find_by_email_for_duplicate_check(&self, email: &str) -> InfrastructureResult<bool> {
        let email_index = self.email_index.read().await;
        Ok(email_index.contains_key(email))
    }
}
```

### Query Store (Read Side)
```rust
// src/infrastructure/repository/in_memory_user_query_repository.rs

use crate::application::dto::user::{GetUserResponseDto, ListUsersResponseDto};
use crate::domain::repository::user_repository::UserQueryRepositoryInterface;
use crate::shared::error::{InfrastructureError, InfrastructureResult};
use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

#[derive(Debug, Clone)]
pub struct UserReadModel {
    pub id: String,
    pub email: String,
    pub name: String,
    pub created_at: String,
    pub updated_at: String,
    pub search_terms: String, // æ¤œç´¢ç”¨ã®éæ­£è¦åŒ–ãƒ‡ãƒ¼ã‚¿
}

pub struct InMemoryUserQueryRepository {
    // Readå°‚ç”¨ã‚¹ãƒˆã‚¢ - éæ­£è¦åŒ–ã•ã‚ŒãŸæ¤œç´¢æœ€é©åŒ–ãƒ‡ãƒ¼ã‚¿
    read_models: Arc<RwLock<HashMap<Uuid, UserReadModel>>>,
    email_lookup: Arc<RwLock<HashMap<String, Uuid>>>,
    name_search_index: Arc<RwLock<HashMap<String, Vec<Uuid>>>>, // åå‰æ¤œç´¢ç”¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
}

impl InMemoryUserQueryRepository {
    pub fn new() -> Self {
        Self {
            read_models: Arc::new(RwLock::new(HashMap::new())),
            email_lookup: Arc::new(RwLock::new(HashMap::new())),
            name_search_index: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    // CQRS: Commandå´ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿åŒæœŸï¼ˆå®Ÿéš›ã¯ã‚¤ãƒ™ãƒ³ãƒˆçµŒç”±ï¼‰
    pub async fn sync_from_command_side(&self, user: &crate::domain::entity::user::User) -> InfrastructureResult<()> {
        let read_model = UserReadModel {
            id: user.id().to_string(),
            email: user.email().value().to_string(),
            name: user.name().value().to_string(),
            created_at: user.created_at().format("%Y-%m-%dT%H:%M:%SZ").to_string(),
            updated_at: user.updated_at().format("%Y-%m-%dT%H:%M:%SZ").to_string(),
            search_terms: format!("{} {}", user.name().value(), user.email().value()).to_lowercase(),
        };
        
        let mut read_models = self.read_models.write().await;
        let mut email_lookup = self.email_lookup.write().await;
        let mut name_search_index = self.name_search_index.write().await;
        
        // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ›´æ–°
        email_lookup.insert(read_model.email.clone(), user.id().clone());
        
        // åå‰æ¤œç´¢ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ›´æ–°
        let name_words: Vec<String> = read_model.name
            .split_whitespace()
            .map(|s| s.to_lowercase())
            .collect();
            
        for word in name_words {
            name_search_index
                .entry(word)
                .or_insert_with(Vec::new)
                .push(user.id().clone());
        }
        
        read_models.insert(user.id().clone(), read_model);
        
        println!("[CQRS] Read model updated for user: {}", user.id());
        Ok(())
    }
}

#[async_trait]
impl UserQueryRepositoryInterface for InMemoryUserQueryRepository {
    async fn find_by_id(&self, id: &Uuid) -> InfrastructureResult<Option<GetUserResponseDto>> {
        let read_models = self.read_models.read().await;
        
        if let Some(read_model) = read_models.get(id) {
            Ok(Some(GetUserResponseDto {
                id: read_model.id.clone(),
                email: read_model.email.clone(),
                name: read_model.name.clone(),
                created_at: read_model.created_at.clone(),
                updated_at: read_model.updated_at.clone(),
            }))
        } else {
            Ok(None)
        }
    }
    
    async fn find_by_email(&self, email: &str) -> InfrastructureResult<Option<GetUserResponseDto>> {
        let email_lookup = self.email_lookup.read().await;
        let read_models = self.read_models.read().await;
        
        if let Some(user_id) = email_lookup.get(email) {
            if let Some(read_model) = read_models.get(user_id) {
                return Ok(Some(GetUserResponseDto {
                    id: read_model.id.clone(),
                    email: read_model.email.clone(),
                    name: read_model.name.clone(),
                    created_at: read_model.created_at.clone(),
                    updated_at: read_model.updated_at.clone(),
                }));
            }
        }
        
        Ok(None)
    }
    
    async fn find_all(&self, limit: Option<i32>, offset: Option<i32>) -> InfrastructureResult<ListUsersResponseDto> {
        let read_models = self.read_models.read().await;
        
        let mut users: Vec<_> = read_models.values().collect();
        
        // ä½œæˆæ—¥æ™‚ã§ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
        users.sort_by(|a, b| b.created_at.cmp(&a.created_at));
        
        // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³
        let offset = offset.unwrap_or(0) as usize;
        let limit = limit.unwrap_or(50) as usize;
        
        let total = users.len();
        let paginated_users: Vec<GetUserResponseDto> = users
            .into_iter()
            .skip(offset)
            .take(limit)
            .map(|read_model| GetUserResponseDto {
                id: read_model.id.clone(),
                email: read_model.email.clone(),
                name: read_model.name.clone(),
                created_at: read_model.created_at.clone(),
                updated_at: read_model.updated_at.clone(),
            })
            .collect();
        
        Ok(ListUsersResponseDto {
            users: paginated_users,
            total: total as i32,
            limit: limit as i32,
            offset: offset as i32,
        })
    }
    
    async fn search_by_name(&self, query: &str) -> InfrastructureResult<Vec<GetUserResponseDto>> {
        let name_search_index = self.name_search_index.read().await;
        let read_models = self.read_models.read().await;
        
        let search_term = query.to_lowercase();
        let mut matching_user_ids = Vec::new();
        
        // åå‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰æ¤œç´¢
        for (indexed_word, user_ids) in name_search_index.iter() {
            if indexed_word.contains(&search_term) {
                matching_user_ids.extend(user_ids);
            }
        }
        
        // é‡è¤‡é™¤å»
        matching_user_ids.sort();
        matching_user_ids.dedup();
        
        let results: Vec<GetUserResponseDto> = matching_user_ids
            .into_iter()
            .filter_map(|user_id| read_models.get(&user_id))
            .map(|read_model| GetUserResponseDto {
                id: read_model.id.clone(),
                email: read_model.email.clone(),
                name: read_model.name.clone(),
                created_at: read_model.created_at.clone(),
                updated_at: read_model.updated_at.clone(),
            })
            .collect();
        
        Ok(results)
    }
}
```

## ğŸ”„ CQRS Repository Interfaces

### Separated Command and Query Interfaces
```rust
// src/domain/repository/user_repository.rs

use crate::domain::entity::user::User;
use crate::application::dto::user::{GetUserResponseDto, ListUsersResponseDto};
use crate::shared::error::InfrastructureResult;
use async_trait::async_trait;
use uuid::Uuid;

// Command Side (Write Operations)
#[async_trait]
pub trait UserCommandRepositoryInterface: Send + Sync {
    async fn save(&self, user: &User) -> InfrastructureResult<()>;
    async fn delete(&self, id: &Uuid) -> InfrastructureResult<()>;
    async fn find_by_email_for_duplicate_check(&self, email: &str) -> InfrastructureResult<bool>;
}

// Query Side (Read Operations)
#[async_trait]
pub trait UserQueryRepositoryInterface: Send + Sync {
    async fn find_by_id(&self, id: &Uuid) -> InfrastructureResult<Option<GetUserResponseDto>>;
    async fn find_by_email(&self, email: &str) -> InfrastructureResult<Option<GetUserResponseDto>>;
    async fn find_all(&self, limit: Option<i32>, offset: Option<i32>) -> InfrastructureResult<ListUsersResponseDto>;
    async fn search_by_name(&self, query: &str) -> InfrastructureResult<Vec<GetUserResponseDto>>;
}
```

## ğŸ¯ UseCase Implementation with CQRS

### Command UseCase
```rust
// src/application/usecase/user/create_user_usecase.rs

use crate::application::dto::user::{CreateUserRequestDto, CreateUserResponseDto};
use crate::domain::entity::user::User;
use crate::domain::repository::user_repository::UserCommandRepositoryInterface;
use crate::domain::service::id_generator::IdGeneratorInterface;
use crate::shared::error::{ApplicationError, ApplicationResult};
use async_trait::async_trait;
use std::sync::Arc;

#[async_trait]
pub trait CreateUserUsecaseInterface: Send + Sync {
    async fn execute(&self, request_dto: CreateUserRequestDto) -> ApplicationResult<CreateUserResponseDto>;
}

pub struct CreateUserUseCase<T, U>
where
    T: UserCommandRepositoryInterface + Send + Sync,
    U: IdGeneratorInterface + Send + Sync,
{
    command_repository: Arc<T>, // Commandå´ã®Repository
    id_generator: Arc<U>,
}

impl<T, U> CreateUserUseCase<T, U>
where
    T: UserCommandRepositoryInterface + Send + Sync,
    U: IdGeneratorInterface + Send + Sync,
{
    pub fn new(command_repository: Arc<T>, id_generator: Arc<U>) -> Self {
        Self {
            command_repository,
            id_generator,
        }
    }
}

#[async_trait]
impl<T, U> CreateUserUsecaseInterface for CreateUserUseCase<T, U>
where
    T: UserCommandRepositoryInterface + Send + Sync,
    U: IdGeneratorInterface + Send + Sync,
{
    async fn execute(&self, request_dto: CreateUserRequestDto) -> ApplicationResult<CreateUserResponseDto> {
        // 1. Business Logic Validation
        if self.command_repository
            .find_by_email_for_duplicate_check(&request_dto.email)
            .await
            .map_err(ApplicationError::Infrastructure)?
        {
            return Err(ApplicationError::EmailAlreadyExists {
                email: request_dto.email,
            });
        }
        
        // 2. Domain Entity Creation
        let user_id = self.id_generator.generate();
        let user = User::new(
            user_id,
            request_dto.email,
            request_dto.name,
            request_dto.password,
        ).map_err(ApplicationError::Domain)?;
        
        // 3. Command Execution (Write Side)
        self.command_repository
            .save(&user)
            .await
            .map_err(ApplicationError::Infrastructure)?;
        
        // 4. Return Response (from Domain Entity)
        Ok(CreateUserResponseDto::from(user))
    }
}
```

### Query UseCase
```rust
// src/application/usecase/user/get_user_usecase.rs

use crate::application::dto::user::{GetUserRequestDto, GetUserResponseDto};
use crate::domain::repository::user_repository::UserQueryRepositoryInterface;
use crate::shared::error::{ApplicationError, ApplicationResult};
use async_trait::async_trait;
use std::sync::Arc;

#[async_trait]
pub trait GetUserUsecaseInterface: Send + Sync {
    async fn execute(&self, request_dto: GetUserRequestDto) -> ApplicationResult<GetUserResponseDto>;
}

pub struct GetUserUseCase<T>
where
    T: UserQueryRepositoryInterface + Send + Sync,
{
    query_repository: Arc<T>, // Queryå´ã®Repository
}

impl<T> GetUserUseCase<T>
where
    T: UserQueryRepositoryInterface + Send + Sync,
{
    pub fn new(query_repository: Arc<T>) -> Self {
        Self { query_repository }
    }
}

#[async_trait]
impl<T> GetUserUsecaseInterface for GetUserUseCase<T>
where
    T: UserQueryRepositoryInterface + Send + Sync,
{
    async fn execute(&self, request_dto: GetUserRequestDto) -> ApplicationResult<GetUserResponseDto> {
        // Query Execution (Read Side)
        let user = self.query_repository
            .find_by_id(&request_dto.id)
            .await
            .map_err(ApplicationError::Infrastructure)?;
        
        match user {
            Some(user_dto) => Ok(user_dto),
            None => Err(ApplicationError::UserNotFound {
                id: request_dto.id.to_string(),
            }),
        }
    }
}
```

## ğŸ”§ DI Setup with CQRS Separation

```rust
// src/main.rs

use crate::infrastructure::repository::{
    InMemoryUserCommandRepository,
    InMemoryUserQueryRepository,
};

async fn setup_dependencies() -> ApplicationResult<AppState> {
    // Infrastructure Layer - CQRS Repositories
    let command_repository = Arc::new(InMemoryUserCommandRepository::new());
    let query_repository = Arc::new(InMemoryUserQueryRepository::new());
    let id_generator = Arc::new(UuidGenerator::new());
    
    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿æŠ•å…¥
    seed_test_data(&command_repository, &query_repository).await?;
    
    // Application Layer - Command UseCases
    let create_user_usecase = Arc::new(CreateUserUseCase::new(
        command_repository.clone(),
        id_generator.clone(),
    ));
    
    // Application Layer - Query UseCases  
    let get_user_usecase = Arc::new(GetUserUseCase::new(
        query_repository.clone(),
    ));
    
    let list_users_usecase = Arc::new(ListUsersUseCase::new(
        query_repository.clone(),
    ));
    
    Ok(AppState {
        // Command UseCases
        create_user_usecase,
        update_user_usecase,
        delete_user_usecase,
        
        // Query UseCases
        get_user_usecase,
        list_users_usecase,
        search_users_usecase,
    })
}

async fn seed_test_data(
    command_repo: &Arc<InMemoryUserCommandRepository>,
    query_repo: &Arc<InMemoryUserQueryRepository>,
) -> ApplicationResult<()> {
    let test_users = vec![
        User::new(
            Uuid::new_v4(),
            "alice@example.com".to_string(),
            "Alice Smith".to_string(),
            "password123".to_string(),
        )?,
        User::new(
            Uuid::new_v4(),
            "bob@example.com".to_string(),
            "Bob Johnson".to_string(),
            "password456".to_string(),
        )?,
    ];
    
    // Commandå´ã«ãƒ‡ãƒ¼ã‚¿æŠ•å…¥
    command_repo.seed_data(test_users.clone()).await?;
    
    // Queryå´ã«åŒæœŸ
    for user in test_users {
        query_repo.sync_from_command_side(&user).await?;
    }
    
    Ok(())
}
```

## âœ… Benefits of In-Memory CQRS

### ğŸ¨ **Pure Clean Architecture Focus**
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼ãªã—
- ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç¾ã—ã•ãŒéš›ç«‹ã¤
- ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã«é›†ä¸­å¯èƒ½

### ğŸ”„ **True CQRS Separation**
- Command/Query ã®è²¬å‹™ãŒæ˜ç¢º
- Read/Write ã®æœ€é©åŒ–ãŒåˆ†ã‹ã‚Šã‚„ã™ã„
- å°†æ¥ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°å¯¾å¿œã‚‚ç°¡å˜

### âš¡ **High Development Speed**
- å³åº§ã«å‹•ä½œç¢ºèªå¯èƒ½
- ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚‚ç°¡å˜ã«æŠ•å…¥
- CRUDã®å‹•ä½œãŒç›®ã«è¦‹ãˆã‚‹

### ğŸ§ª **Perfect for Testing**
- ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã§å®Œå…¨ãƒ†ã‚¹ãƒˆ
- çŠ¶æ…‹ã®ãƒªã‚»ãƒƒãƒˆãŒç°¡å˜
- ä¸¦è¡Œå®Ÿè¡Œãƒ†ã‚¹ãƒˆã‚‚å¯èƒ½

å¾Œã§PostgreSQLã«ç§»è¡Œã™ã‚‹æ™‚ã‚‚ã€Repositoryå®Ÿè£…ã‚’å·®ã—æ›¿ãˆã‚‹ã ã‘ã§æ¸ˆã¿ã¾ã™ï¼

ã¾ãšã¯**ã“ã®ç¾ã—ã„CQRSæ§‹é€ **ã§å®Œå…¨ãªCAã‚’æ§‹ç¯‰ã—ã¾ã›ã‚“ã‹ï¼ŸğŸ¯